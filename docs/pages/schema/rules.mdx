import { Steps } from "nextra/components";
import { Aside } from "../../components/Aside";

# Rules

The ents in your database are only accessible via server-side functions, and so
you can rely on their implementation to enforce authorization rules (also known
as "row level security").

But you might have multiple functions accessing the same data, and you might be
using the different methods provided by Convex Ents to access them:

- To read: `get`, `getX`, `edge`, `edgeX`, `unique`, `uniqueX`, `first`,
  `firstX`, `take`, etc.
- To write: `insert`, `insertMany`, `patch`, `replace`, `delete`

Enforcing rules about when an ent can be read, created, updated or deleted at
every callsite can be onerous and error-prone.

For this reason you can optionally define a set of "rules" implementations that
are automatically enforced by the `ctx.table` API. This is an advanced feature,
and so it requires a bit more setup.

## Setup

Before setting up rules, make sure you understand how Convex Ents are configured
via custom functions, see [Configuring Functions](/setup/config).

<Steps>

### Define your rules

Add a `rules.ts` file with the following contents:

```ts filename="convex/rules.ts" {41-49}
import {
  addEntRules,
  entsTableFactory,
  entsTableWriterFactory,
} from "../../src";
import { MutationCtx, QueryCtx } from "./_generated/server";
import { entDefinitions } from "./schema";

export async function mutationCtxWithRules(baseCtx: MutationCtx) {
  const { ctx, entDefinitionsWithRules } = await queryCtxWithRules(baseCtx);
  return {
    db: undefined,
    viewer: ctx.viewer,
    skipRules: { table: entsTableWriterFactory(baseCtx, entDefinitions) },
    table: entsTableWriterFactory(baseCtx, entDefinitionsWithRules),
  };
}

export async function queryCtxWithRules(baseCtx: QueryCtx) {
  const ctx = await queryCtxWithViewer(baseCtx);
  const entDefinitionsWithRules = getEntDefinitionsWithRules(ctx);
  // Here we make sure that the rules also apply when they're evaluated
  ctx.table = entsTableFactory(baseCtx, entDefinitionsWithRules);
  return { ctx, entDefinitionsWithRules };
}

async function queryCtxWithViewer(baseCtx: QueryCtx) {
  const ctx = queryCtxForLoadingViewer(baseCtx);
  const viewer = await getViewer(ctx);
  return {
    ...ctx,
    viewer,
    // This one is here just for its type, and won't be used at runtime
    table: entsTableFactory(baseCtx, entDefinitions),
  };
}

function getEntDefinitionsWithRules(
  ctx: Awaited<ReturnType<typeof queryCtxWithViewer>>
) {
  return addEntRules(entDefinitions, {
    // "secrets" is one of our tables
    secrets: {
      read: async (secret) => {
        // Example: Only the viewer can see their secret
        return ctx.viewer?._id === secret.userId;
      },
    },
  });
}

function queryCtxForLoadingViewer(baseCtx: QueryCtx) {
  return {
    ...baseCtx,
    db: undefined,
    skipRules: { table: entsTableFactory(baseCtx, entDefinitions) },
  };
}

async function getViewer(ctx: ReturnType<typeof queryCtxForLoadingViewer>) {
  // TODO: Implement me via `ctx.skipRules.table()`
  return null;
}
```

This code defines 4 versions of `ctx`, from the bottom of the file:

1. `queryCtxForLoadingViewer` is used to retrieve the viewer. Authorization
   commonly has a concept of a viewer, although this is totally up to your use
   case. This version has `ctx.skipRules.table` available, which does not
   enforce any rules. It also doesn't have `ctx.viewer`, since it's used to
   define it.
2. `queryCtxWithViewer` is used to define the rules. In addition to the first
   context, it has `ctx.viewer` available. It has `ctx.table`, which is used to
   declare its type in the signature of `getEntDefinitionsWithRules`.
3. `queryCtxWithRules` will be used in queries, and it also exposes
   `entDefinitionsWithRules` for define mutation `ctx`.
   - It takes the `queryCtxWithViewer` and passes it to
     `getEntDefinitionsWithRules` , and then mutates it so that its `ctx.table`
     also uses those rules. This way
     [read rules can depend on other read rules](#delegating-to-another-ent).
4. `mutationCtxWithRules` is used in mutations. Because it uses the mutable
   version of the built-in `ctx`, it has to redefine `ctx.skipRules.table` and
   `ctx.table` (and optionally `db`).

The call to `addEntRules`, which takes `entDefinitions` from our schema, and
adds any rules you specify, returning augmented `entDefinitions`, is where the
rules are actually defined.

### Apply rules

Back in your `functions.ts` file, use the `queryCtxWithRules` and
`mutationCtxWithRules` you defined in `rules.ts`:

```ts filename="convex/functions.ts" {13,18,30,42,54}
import {
  customCtx,
  customMutation,
  customQuery,
} from "convex-helpers/server/customFunctions";
import {
  internalMutation as baseInternalMutation,
  internalQuery as baseInternalQuery,
  mutation as baseMutation,
  query as baseQuery,
} from "./_generated/server";
import { mutationCtxWithRules, queryCtxWithRules } from "./rules";

export const query = customQuery(
  baseQuery,
  customCtx(async (baseCtx) => {
    const { ctx } = await queryCtxWithRules(baseCtx);
    return ctx;
  })
);

export const internalQuery = customQuery(
  baseInternalQuery,
  customCtx(async (baseCtx) => {
    const { ctx } = await queryCtxWithRules(baseCtx);
    return ctx;
  })
);

export const mutation = customMutation(
  baseMutation,
  customCtx(async (baseCtx) => {
    return await mutationCtxWithRules(baseCtx);
  })
);

export const internalMutation = customMutation(
  baseInternalMutation,
  customCtx(async (baseCtx) => {
    return await mutationCtxWithRules(baseCtx);
  })
);
```

We structured the setup this way to provide the most consistency of `ctx` used
to fetch the viewer, implement rules and implement your functions.

</Steps>

## Read rules

For each table storing ents you can define a `read` rule implementation. The
implementation is given the ent that is being retrieved, and should return a
`boolean` of whether the ent is readable. This code runs before ents are
returned by `ctx.table`:

- If the retrieval method can return `null`, and the rule returns `false`, then
  `null` is returned. Examples: `get`, `first`, `unique` etc.
- If the retrieval method throws when the ent does not exist, it will also throw
  when the ent cannot be read. Examples: `getX`, `firstX`, `uniqueX`
- If the retrieval method returns a list of ents, then any ents that cannot be
  read will be filtered out.
  - except for `getManyX`, which will throw an `Error`

### Understanding read rules performance

A read rule is essentially a filter, performed in the Convex runtime running
your query or mutation. This means that adding a read rule to a table
fundamentally changes the way methods like `first`, `unique` and `take` are
implemented. These methods need to paginate through the underlying table (or
index range), on top of the scanning that is performed by the built-in `db` API.
You should be mindful of how many ents your read rules might filter out for a
given query.

<Aside title="How exactly do `first`, `unique` and `take` paginate?">
  The methods first try to load the requested number of ents (`1`, `2` or `n`
  respectively). If the ents loaded first get filtered out, the method loads 2
  times more documents, performs the filtering, and if again there aren't enough
  ents, it doubles the number again, and so on, for a maximum of 64 ents being
  evaluated at a time.
</Aside>

### Common read rule patterns

#### Delegating to another ent

```ts
return addEntRules(entDefinitions, {
  profiles: {
    read: async (profile) => {
      return (await profile.edge("user")) !== null;
    },
  },
});
```

When the user connected to the profile can be read, the profile can be read.

Watch out for infinite loops between read rules, and break them up

#### Testing for an edge

```ts
return addEntRules(entDefinitions, {
  users: {
    read: async (user) => {
      return (
        ctx.viewer !== null &&
        (ctx.viewer._id === user._id ||
          (await user.edge("friends").has(ctx.viewer._id)))
      );
    },
  },
});
```

A user ent can be read when it is the viewer or when there is a `"friends"` edge
between the viewer and the user.

## Write rules

Write rules determine whether ents can be created, updated or deleted. They can
be specified using the `write` key:

```ts
return addEntRules(entDefinitions, {
  // "secrets" is one of our tables
  secrets: {
    // Note: The read rule is always checked for existing ents
    // for any updates or deletions
    read: async (secret) => {
      return ctx.viewer?._id === secret.userId;
    },
    write: async ({ operation, ent: secret, value }) => {
      if (operation === "delete") {
        // Example: No one is allowed to delete secrets
        return false;
      }
      if (operation === "create") {
        // Example: Only the viewer can create secrets
        return ctx.viewer?._id === value.ownerId;
      }
      // Example: secret's user edge is immutable
      return value.ownerId === undefined || value.ownerId === secret.ownerId;
    },
  },
});
```

The `read` rule is always checked for updates first. The `write` rule is given
an object with

- `operation`, one of `"create"`, `"update"` or `"delete"`
- `ent`, the existing ent if this is an update or delete
- `value`, the value provided to `.insert()`, `.replace()` or `.patch()`.

The methods `insert`, `insertMany`, `patch`, `replace` and `delete` throw an
`Error` if the `write` rule returns `false`.

## Ignoring rules

Sometimes you might want to read from or write to the database without abiding
by the rules you defined. Perhaps you are running with `ctx` that isn't
authenticated, or your code needs to perform some operation on behalf of a user
who isn't the current viewer.

For this purpose the [Setup](#setup) section above defines
`ctx.skipRules.table`, which is a version of `ctx.table` that can read and write
to the database without checking the rules.

It is preferable to still use Convex Ents over using the built-in `ctx.db` API
for this purpose, to maintain invariants around edges and unique fields. See
[Exposing built-in `db`](/setup/config#exposing-built-in-db).
