import { Steps } from "nextra/components";
import { Aside } from "../../components/Aside";

# Rules

The ents in your database are only accessible via server-side functions, and so
you can rely on their implementation to enforce authorization rules (also known
as "row level security").

But you might have multiple functions accessing the same data, and you might be
using the different methods provided by Convex Ents to access them:

- To read: `get`, `getX`, `edge`, `edgeX`, `unique`, `uniqueX`, `first`,
  `firstX`, `take`, etc.
- To write: `insert`, `insertMany`, `patch`, `replace`, `delete`

Enforcing rules about when an ent can be read, created, updated or deleted at
every callsite can be onerous and error-prone.

For this reason you can optionally define a set of "rules" implementations that
are automatically enforced by the `ctx.table` API. This is an advanced feature,
and so it requires a bit more setup.

## Setup

Before setting up rules, make sure you understand how Convex Ents are configured
via custom functions, see [Configuring Functions](/setup/config).

<Steps>

### Define your rules

Add a `rules.ts` file with the following contents:

```ts filename="convex/rules.ts" {21-29}
import { addEntRules, entsTableFactory } from "convex-ents";
import { QueryCtx } from "./_generated/server";
import { entDefinitions } from "./schema";

export async function ctxProperties<Ctx extends QueryCtx>(ctx: Ctx) {
  const baseCtx = await ctxWithViewer(ctx);
  const entDefinitionsWithRules = getEntDefinitionsWithRules(baseCtx);
  baseCtx.table = entsTableFactory(ctx, entDefinitionsWithRules);
  return { viewer: baseCtx.viewer, entDefinitionsWithRules };
}

async function ctxWithViewer(baseCtx: QueryCtx) {
  const ctx = ctxForLoadingViewer(baseCtx);
  const viewer = await getViewer(ctx);
  return { ...ctx, viewer };
}

function getEntDefinitionsWithRules(
  ctx: Awaited<ReturnType<typeof ctxWithViewer>>
) {
  return addEntRules(entDefinitions, {
    // "secrets" is one of our tables
    secrets: {
      read: async (secret) => {
        // Example: Only the viewer can see their secret
        return ctx.viewer?._id === secret.userId;
      },
    },
  });
}

function ctxForLoadingViewer(baseCtx: QueryCtx) {
  return {
    ...baseCtx,
    table: entsTableFactory(baseCtx, entDefinitions),
    db: undefined,
  };
}

async function getViewer(ctx: ReturnType<typeof ctxForLoadingViewer>) {
  // TODO: Implement me
  return null;
}
```

Here we're creating 3 versions of `ctx`, from the bottom of the file:

1. First version of `ctx` is used to retrieve the viewer. Authorization commonly
   has a concept of a viewer, although this is totally up to your use case. This
   version has `ctx.table` available, but it does not enforce any rules we
   define here. It also doesn't have `ctx.viewer`, since we're just defining it.
2. Second version of `ctx` is used to define the rules. In addition to the first
   context, it has `ctx.viewer` available. This `ctx` is passed to
   `getEntDefinitionsWithRules`, and then mutated so that its `table` also uses
   those rules.
3. Finally we return the `viewer` and `entDefinitions` including our rules from
   `ctxProperties`.

The important piece is the call to `addEntRules`, which takes `entDefinitions`
from our schema, and adds any rules you specify, returning augmented
`entDefinitions`.

### Apply rules

Back in your `functions.ts` file, use the `ctxProperties` function you defined
in `rules.ts`:

```ts filename="convex/functions.ts" {13,18,30,42,54}
import {
  customCtx,
  customMutation,
  customQuery,
} from "convex-helpers/server/customFunctions";
import {
  query as baseQuery,
  mutation as baseMutation,
  internalQuery as baseInternalQuery,
  internalMutation as baseInternalMutation,
} from "./_generated/server";
import { entsTableFactory, entsTableWriterFactory } from "convex-ents";
import { ctxProperties } from "./rules";

export const query = customQuery(
  baseQuery,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableFactory(ctx, entDefinitionsWithRules),
      viewer,
      db: undefined,
    };
  })
);

export const internalQuery = customQuery(
  baseInternalQuery,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableFactory(ctx, entDefinitionsWithRules),
      viewer,
      db: undefined,
    };
  })
);

export const mutation = customMutation(
  baseMutation,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableWriterFactory(ctx, entDefinitionsWithRules),
      viewer,
      db: undefined,
    };
  })
);

export const internalMutation = customMutation(
  baseInternalMutation,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableWriterFactory(ctx, entDefinitionsWithRules),
      viewer,
      db: undefined,
    };
  })
);
```

</Steps>

## Read rules

For each table storing ents you can define a `read` rule implementation. The
implementation is given the ent that is being retrieved, and should return a
`boolean` of whether the ent is readable. This code runs before ents are
returned by `ctx.table`:

- If the retrieval method can return `null`, and the rule returns `false`, then
  `null` is returned. Examples: `get`, `first`, `unique` etc.
- If the retrieval method throws when the ent does not exist, it will also throw
  when the ent cannot be read. Examples: `getX`, `firstX`, `uniqueX`
- If the retrieval method returns a list of ents, then any ents that cannot be
  read will be filtered out.
  - except for `getManyX`, which will throw an `Error`

### Understanding read rules performance

A read rule is essentially a filter, performed in the Convex runtime running
your query or mutation. This means that adding a read rule to a table
fundamentally changes the way methods like `first`, `unique` and `take` are
implemented. These methods need to paginate through the underlying table (or
index range), on top of the scanning that is performed by the built-in `db` API.
You should be mindful of how many ents your read rules might filter out for a
given query.

<Aside title="How exactly do `first`, `unique` and `take` paginate?">
  The methods first try to load the requested number of ents (`1`, `2` or `n`
  respectively). If the ents loaded first get filtered out, the method loads 2
  times more documents, performs the filtering, and if again there aren't enough
  ents, it doubles the number again, and so on, for a maximum of 64 ents being
  evaluated at a time.
</Aside>

## Common read rule patterns

### Delegating to another ent

```ts
return addEntRules(entDefinitions, {
  profiles: {
    read: async (profile) => {
      return (await profile.edge("user")) !== null;
    },
  },
});
```

When the user connected to the profile can be read, the profile can be read.

Watch out for infinite loops between read rules, and break them up

### Testing for an edge

```ts
return addEntRules(entDefinitions, {
  users: {
    read: async (user) => {
      return (
        ctx.viewer !== null &&
        (ctx.viewer._id === user._id ||
          (await user.edge("friends").has(ctx.viewer._id)))
      );
    },
  },
});
```

A user ent can be read when it is the viewer or when there is a `"friends"` edge
between the viewer and the user.

## Write rules

Write rules determine whether ents can be created, updated or deleted. They can
be specified using the `write` key:

```ts
return addEntRules(entDefinitions, {
  // "secrets" is one of our tables
  secrets: {
    // Note: The read rule is always checked for existing ents
    // for any updates or deletions
    read: async (secret) => {
      return ctx.viewer?._id === secret.userId;
    },
    write: async ({ operation, ent: secret, value }) => {
      if (operation === "delete") {
        // Example: No one is allowed to delete secrets
        return false;
      }
      if (operation === "create") {
        // Example: Only the viewer can create secrets
        return ctx.viewer?._id === value.ownerId;
      }
      // Example: secret's user edge is immutable
      return value.ownerId === undefined || value.ownerId === secret.ownerId;
    },
  },
});
```

The `read` rule is always checked for updates first. The `write` rule is given
an object with

- `operation`, one of `"create"`, `"update"` or `"delete"`
- `ent` the existing ent if this is an update or delete
- `values`, the values provided to `.replace()` or `.patch()`.

The methods `insert`, `insertMany`, `patch`, `replace`, `delete` throw an
`Error` if the `write` rule returns `false`.

## Ignoring rules

Sometimes you might want to read from or write to the database without abiding
the rules you defined. Perhaps you are running with `ctx` that isn't
authenticated, or your code needs to perform some operation on behalf of a user
who isn't the current viewer. For these purposes you can set up an additional
API on `ctx`:

```ts filename="convex/functions.ts" {13, 22, 35, 48, 61}
import {
  customCtx,
  customMutation,
  customQuery,
} from "convex-helpers/server/customFunctions";
import {
  query as baseQuery,
  mutation as baseMutation,
  internalQuery as baseInternalQuery,
  internalMutation as baseInternalMutation,
} from "./_generated/server";
import { entsTableFactory, entsTableWriterFactory } from "convex-ents";
import { entDefinitions } from "./schema";
import { ctxProperties } from "./rules";

export const query = customQuery(
  baseQuery,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableFactory(ctx, entDefinitionsWithRules),
      skipRules: { table: entsTableFactory(ctx, entDefinitions) },
      viewer,
      db: undefined,
    };
  })
);

export const internalQuery = customQuery(
  baseInternalQuery,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableFactory(ctx, entDefinitionsWithRules),
      skipRules: { table: entsTableFactory(ctx, entDefinitions) },
      viewer,
      db: undefined,
    };
  })
);

export const mutation = customMutation(
  baseMutation,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableWriterFactory(ctx, entDefinitionsWithRules),
      skipRules: {
        table: entsTableWriterFactory(ctx, entDefinitions),
      },
      viewer,
      db: undefined,
    };
  })
);

export const internalMutation = customMutation(
  baseInternalMutation,
  customCtx(async (ctx) => {
    const { viewer, entDefinitionsWithRules } = await ctxProperties(ctx);
    return {
      table: entsTableWriterFactory(ctx, entDefinitionsWithRules),
      skipRules: {
        table: entsTableWriterFactory(ctx, entDefinitions),
      },
      viewer,
      db: undefined,
    };
  })
);
```

In this example we called it `ctx.skipRules.table`, which is a version of
`ctx.table` that can read every ent and write to every ent.

It is preferable to still use Convex Ents over using the built-in `ctx.db` API
to maintain invariants around edges and unique fields, see
[Exposing built-in `db`](/setup/config#exposing-built-in-db).
